// Copyright (c) 2004-2020 Microchip Technology Inc. and its subsidiaries.
// SPDX-License-Identifier: MIT

= MEPA Instantiation
== MEPA Instantiation

== Introduction

The MEPA library operates on MEPA instances, which represents the physical
PHYs. Some products contains multiple PHYs in a single packets (example a quad
PHY), here the multiple PHYs may share some resources like GPIOs, or maybe they
uses a single QSGMII host interface. In case of a multi-PHY product MEPA
requires an instance for each PHY, the instances are then linked together to
coordinate any potential resource sharing.

As the first step, even before creating instances, a trace functions can be
installed. This will allow MEPA to print diagnostics which can be very helpful
to debug potential issues. Registering a trace functions is a matter of
assigning a function pointer of type `mepa_trace_func_t` to MEPA_TRACE_FUNCTION.

The MEPA instances needs to be created by the application. A MEPA instance is
created by calling `mepa_create()`, which on success returns a `mepa_device_t`
pointer. The `mepa_device_t` represents a single PHY, and must be used with all
other MEPA APIs operating on a given PHY.

In order for MEPA to be able to configure/query a given PHY, it needs to access
the registers in side the PHY. To access PHY registers, some kind of
bus-controller is needed (example MIIM), and if it is a shared bus, some
addresses are needed. To keep MEPA board and OS agnostic, a set of call-back
functions facilitating register access must be provided when creating a MEPA
instance (see `struct mepa_callout`). A given board may have multiple buses,
multiple PHYs, which lead to board specific needs for addressing a given PHYs.
To avoid board dependencies in MEPA, all the callback functions therefore have a
`struct mepa_callout_cxt`, defined and provided by the application itself, and
only used by the application when the callback functions are used. Both the
`mepa_callout_t` and `mepa_callout_ctx` object pointers are considered shared
pointers, meaning that the memory pointing to must remain valid during the
entire life time of the `mepa_device_t` instance. Multiple `mepa_device_t` may
use the same `mepa_callout_t` object (all PHYs on the same bus _must_ use the
same `mepa_callout_t` object, this is because they all share the bus resources,
and in multi-threaded application accesses to the bus needs to be synchronized),
and each `mepa_device_t` instance should have its own unique `struct
mepa_callout_ctx`.

== Callout APIs

Callout APIs are API functions provided by the customer which are passed into
MEPA in an argument of the `mepa_create()` function.

These functions include callbacks for MIIM read/writes used access registers.
Synchronization callbacks provide support for lock enter/exit needed in
multi-threaded environments. Trace callback functions provide debug support.

Register/MIIM accessor functions are used in the MEPA Bus Access Function layer as
illustarted in link:#mepa/docs/introduction[Architecture] section.

=== Trace

The API `mepa_trace_func_t()` provides a trace system, which may be controlled and
mapped into the trace system of the application software. Trace macros inside the
API have these properties:

* Trace group (`mepa_trace_group_t`)
* Trace level (`mepa_trace_level_t`)
* Location, line and format.

The current trace level can be controlled per group. Trace levels may
be changed before initialization for debugging the startup.

The MEPA trace function is a single global variable. Traces will only work when
a function is assigned to MEPA_TRACE_FUNCTION.

For trace callback `mepa_trace_func_t`, application specific implementation
must be passed to print the traces supported by API. For LAN8814, the trace flag
`MEPA_TRACE_GRP_GEN` can be used to enable General PHY related traces. Each
application may have its own conditions on when to enable traces. When the
callback `mepa_trace_func_t` is executed, application can print or ignore the
trace call depending on its own enabling conditions.

=== Register Access

Device registers can be accessed using these APIs (`mepa_mmd_read_t`,
`mepa_mmd_read_inc_t`, `mepa_mmd_write_t`, `mepa_miim_read_t`,
`mepa_miim_write_t`).

=== Synchronization Functions

The APIs `mepa_callout_t::lock_enter` and
`mepa_callout_t::lock_exit` are synchronization callbacks for
which application specific semaphore implementation must be allocated,
initialized, and passed in `mepa_driver_probe_t`.

These APIs are called before entering API and exiting API. These callbacks
provide synchronized access for all the MEPA calls.

== General MEPA usage

Once the MEPA instance has been created, the MEPA API can be used. In the
example above all the instances are kept in the `APPL_mepa_devices` array. When
calling the MEPA APIs, this array needs to be referenced to get the `struct
mepa_device *` pointer. This is shown in the example below:

----
void APPL_example1(int port_no) {
    mepa_rc rc;

    mepa_aneg_status_t aneg_status;
    rc = mepa_aneg_status_get(APPL_mepa_devices[port_no], &aneg_status);
    if (rc != MEPA_RC_OK) {
        // handle error!
    }

    // Use aneg_status
}
----


MEPA functions which requires a structure as input, but which is not
configuration, should ensure that the entire structure is set to zero before
configuring the input parameters. This is because future MEPA releases may add
more structure members, and to gain backwards compatibility, MEPA is designed
such that the default/neutral value is null. `mepa_reset` is performing an
action, and is therefore not considered configuration. Calling this API is shown
below:

----
void APPL_example2_a(int port_no) {
    mepa_rc rc;
    mepa_reset_param_t rst_conf = {};
    rst_conf.media_intf = MESA_PHY_MEDIA_IF_CU;
    rst_conf.reset_point= MEPA_RESET_POINT_PRE;

    rc = mepa_reset(APPL_mepa_devices[port_no], &rst_conf);
    if (rc != MEPA_RC_OK) {
        // handle error!
    }
}

void APPL_example2_b(int port_no) {
    mepa_rc rc;
    mepa_reset_param_t rst_conf;
    memset(&rst_conf, 0, sizeof(rst_conf));
    rst_conf.media_intf = MESA_PHY_MEDIA_IF_CU;
    rst_conf.reset_point= MEPA_RESET_POINT_PRE;

    rc = mepa_reset(APPL_mepa_devices[port_no], &rst_conf);
    if (rc != MEPA_RC_OK) {
        // handle error!
    }
}
----

== MEPA Configurations

MEPA functions which requires a structure as input, and which is used to
configure the PHY, and which offers a `_get()/_set()` variant, should call the
get before setting. Again, this is to gain backwards compatibility, as future
MEPA versions may add more members which is does not necessary have a
default/neutral null setting.

----
void APPL_example3(int port_no) {
    mepa_rc rc;
    mepa_conf_t conf;

    rc = mepa_conf_get(APPL_mepa_devices[port_no], &conf);
    if (rc != MEPA_RC_OK) {
        // handle error!
    }

    // Update config
    conf.admin.enable = 1;

    rc = mepa_conf_set(APPL_mepa_devices[port_no], &conf);
    if (rc != MEPA_RC_OK) {
        // handle error!
    }
}
----

== Port Link Up Sequence

Port Link Up Configuration Sequence can be Inferred from : link:#mepa/docs/linkup_config[Link Up Configuration]
