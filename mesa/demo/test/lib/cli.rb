# Copyright (c) 2004-2020 Microchip Technology Inc. and its subsidiaries.
# SPDX-License-Identifier: MIT

require 'thread'
require 'rubygems'
require 'net/telnet'
require 'expect'                # Adds instance method IO#expect -- and we use it for the serial port
require 'serialport'
#require 'log_rpt'
#require 'consts'
#require 'mac_address'

#
# CLI Transport classes. A CLI instance uses a CLI transport instance for I/O.
#

class QueueWithTimeout
    def self.debug
        @@debug
    end
    def self.debug=(val)
        @@debug = val
    end
    def initialize
        @mutex = Mutex.new
        @queue = []
        @recieved = ConditionVariable.new
        @@debug = false
    end

    def <<(x)
        Log.info("QueueWithTimeout.<<(): enter '#{x}'") if @@debug
        @mutex.synchronize do
            Log.info("QueueWithTimeout.<<(): got mutex") if @@debug
            @queue << x
            @recieved.signal
        end
        Log.info("QueueWithTimeout.<<(): exit") if @@debug
    end

    def pop(timeout = nil)
        res = nil
        to_err = nil
        Log.info("QueueWithTimeout.pop(): enter") if @@debug
        @mutex.synchronize do
            Log.info("QueueWithTimeout.pop(): got mutex") if @@debug
            if @queue.empty?
                Log.info("QueueWithTimeout.pop(): wait for rx_queue") if @@debug
                @recieved.wait(@mutex, timeout)
                to_err = @queue.empty?
                Log.info("QueueWithTimeout.pop(): woke from rx_queue with queue #{(to_err) ? "empty" : "not empty"}") if @@debug
            end
            res = @queue.shift unless to_err
            Log.info("QueueWithTimeout.pop(): woke from rx_queue with res:'#{res}'") if @@debug and not to_err
        end
        raise Timeout::Error if to_err
        Log.info("QueueWithTimeout.pop(): returning res:'#{res}'") if @@debug
        return res
    end

    def flush
        @mutex.synchronize do
            res = @queue
            @queue = []
            return res
        end
    end

    def unshift(x)
        @mutex.synchronize do
            @queue.unshift(x)
        end
    end
end

class CliTransportError < StandardError
end

class CliTransport
    attr_accessor :debug, :id
    def initialize(target, options = {})
        @target = target
        @debug  = false
        @prompt = ""
        @id = options.fetch(:id, "CliTransport")
        @rx_queue = QueueWithTimeout.new
        rx_start
    end

    def close
        @rx_thr.kill
        @rx_thr.join
    end

    def prompt=(regexp)
        @prompt = regexp
    end

    def flush
        @rx_queue.flush.join
    end

    def pop(timeout = nil)
        @rx_queue.pop(timeout)
    end

    def alive?
        (@rx_thr.alive?) and not self.closed?
    end

    def expect(regexp, timeout, options = {})
        begin
            start = Time.now
            res = @rx_queue.flush.join
            #res = ICli.de_backspace(res) if options[:de_backspace]
            loop do
                if (res =~ regexp)
                    yield res if block_given?
                    return res
                end
                to = timeout - (Time.now - start).floor
                raise Timeout::Error if (to <= 0)
                data = @rx_queue.pop(to)
                res << data if data
                #res = ICli.de_backspace(res) if options[:de_backspace]
            end
        rescue Timeout::Error
            @rx_queue.unshift(res)
            Log.info("#{id}: Timeout while waiting for data (#{regexp.to_s})") unless Cli.quiet
            raise CliTransportError.new("#{id}: Dead transport") unless alive?
            return nil
        rescue EOFError
            Log.info("#{id}: Got EOFError") unless Cli.quiet
            close
            raise CliTransportError.new("#{id}: Terminated with EOFError")
        end
    end

    def rx_start
        @rx_thr = Thread.new do

            # The Transport was originally intended to be transparent, i.e. do no processing of input
            # and leave that to its clients. But with the introduction of threading this has become
            # harder to deal with without sacrificing performance. So now we've moved the CR/LF
            # processing logic here. So now lines generated by the reader always end with '\n', no
            # matter what kind of CR/LF sequencing is used.
            #
            # This makes clients more robust, but sacrifices the ability to get the "raw" data
            # stream. We used to have that ability exposed, but according to 'grep' nobody used it
            # anyway...
            #
            # So: State machine to the rescue: We generate LF upon the first character being either
            # CR or LF, and then throw away specific following characters, like this:
            #
            #   * CR + LF => LF
            #   * CR + \0 + LF => LF: MOXA terminal server injects superfluous \0 inbetween CR and LF
            #   * LF + CR => LF
            #   * CR => LF
            #   * (Special case:) CR + CR + CR... => LF, LF, LF...
            #
            # One note: The reason why we no longer just do gsub on strings has to do with timing:
            # for one reason or another there's sometimes a sizeable delay between the CR and the
            # following LF, causing the receive logic to enqueue a line ending with CR, and then
            # another (empty) line ending with LF when that LF arrives. This leads the client to
            # think that we got two lines where all we really got was one.
            #
            # But it gives us a performance win: We process the line already with the CR and leave
            # the thread to consume the LF while the client moves on with its processing.
            stm = {
                # Input char, state     => add_char, next state  (add_char == nil means don't add char)
                ["\r", :idle]           => [ "\n", :skip_null_lf ],
                ["\r", :skip_cr]        => [ nil,  :idle],
                ["\r", :skip_null_lf]   => [ "\n", :skip_null_lf],      # CR, CR => LF, LF (in case the serial port doesn't send LFs)
                ["\0", :skip_null_lf]   => [ nil,  :skip_lf],
                ["\n", :skip_null_lf]   => [ nil,  :idle],
                ["\n", :skip_lf]        => [ nil,  :idle],
                ["\n", :idle]           => [ "\n", :skip_cr]
            }
            state = :idle

            rx_buf = ""
            loop do
                begin
                    if rx_buf == ""
                        data = recv # no timeout, so blocking wait for anything.
                    else
                        # We have got a non-complete line in rx_buf, so try to complete it.
                        data = recv(0.01) # A small timeout in seconds
                    end

                    (data || "").each_char do |ch|
                        nxt = stm[[ch, state]]
                        if nxt
                            rx_buf << nxt[0] if nxt[0]
                            state = nxt[1]
                        else
                            rx_buf << ch
                            state = :idle
                        end

                    end

                    puts "rx_buf A:" + rx_buf.inspect + "  data:" + data.inspect if ENV['DEBUG']
                    part = rx_buf.rpartition(/\n/)
                    if part[1] != ""
                        # Enqueue the completed lines
                        #ICli.de_backspace(part[0..1].join).split("\n").each do |ln| Log.info("#{id} RX: <#{ln}>") end unless Cli.quiet
                        @rx_queue << part[0..1].join
                        rx_buf = part[2]
                    elsif ((not data) and (rx_buf != ""))
                        # Enqueue whatever we have got, and reset rx_buf
                        #ICli.de_backspace(rx_buf).split("\n").each do |ln| Log.info("#{id} RX: <#{ln}>") end unless Cli.quiet
                        @rx_queue << rx_buf
                        rx_buf = ""
                    end
                rescue => msg
                    Log.warn("#{id}: Caught: #{msg.to_s}") unless Cli.quiet
                    Log.backtrace(msg) unless Cli.quiet
                end
            end
        end
        return @rx_thr
    end

    # Expect timeout in seconds. Blocking if nil.
    def recv(timeout = nil)
        raise "Must be implemented in subclass!"
    end
end

class CliRs232Transport < CliTransport
    attr_accessor :device
    def initialize(target, options={})
        @id = options.fetch(:id, "CliTransport")
        raise "Invalid rs232 specification: #{target}" unless target =~ /^rs232:([^:]+),(230400|115200|57600|38400|19200|9600|4800|2400|1200|300),([noeNOE]),([5678]),([12])(,transient)?$/
        @dev, baudrate, parity, databits, stopbits, @transient = $1, $2.to_i, $3.upcase, $4.to_i, $5.to_i, $6
        raise "No such character device on host: #{@dev}" unless @transient || (File.exist?(@dev) && File.chardev?(@dev))

        lock_name = "/var/lock/LCK..#{File.basename(@dev)}"
        raise "CLI: Serial port lock file exists, maybe from minicom? #{lock_name}" if File.exist?(lock_name)

        @setup = {
            "baud"      => baudrate,
            "data_bits" => databits,
            "stop_bits" => stopbits,
            "parity"    => { 'N' => SerialPort::NONE, 'O' => SerialPort::ODD, 'E' => SerialPort::EVEN }[parity]
        }
        Log.info("RS232: Opening #{target}") if @debug
        dev_init
        super(target, options)
    end

    def close
        @device.close if @device
        super
    end

    def closed?
        (not @transient) and ((not @device) or @device.closed?)
    end

    def send_str(str)
        if @transient
            @device.print(str) rescue nil
        else
            @device.print(str)
        end
    end

    # Expect timeout in seconds. Blocking if nil.
    def recv(timeout = nil)
        loop do
            if @transient
                while not (@device and @device.tty?)
                    dev_init
                    sleep(0.5)
                end
            end
            data = @device.expect(/.+/, (timeout ? timeout : 99999999))
            data = data[0] if data
            if timeout
                return (data ? data.tr("\a", "") : nil)
            else
                return data.tr("\a", "") if data
            end
        end
    end

    private

    def dev_init
        begin
            @device.close if @device
            @device = ::SerialPort.new(@dev, @setup)
        rescue Exception => e
            raise "Cannot open serial port #{@dev}" unless @transient
            @device = nil
            return nil
        end
        @device.flow_control = SerialPort::NONE
    end
end

class CliTelnetTransport < CliTransport
    def initialize(target, options={})
        @target = target
        @host_mutex = Mutex.new
        @do_proxy = options.fetch(:do_proxy, false)
        @id = options.fetch(:id, "CliTransport")
        restart(false)
        super(target, options)
    end

    def close
        @host_mutex.synchronize do
            @host.close if @host
            @host = nil
            super
        end
    end

    def closed?
        (not @host) or @host.sock.closed?
    end

    def send_str(str)
        1.upto(3) do
            begin
                hst = @host
                hst.print(str)
                return true
            rescue Errno::EPIPE
                Log.info("#{id}: send_str() restarting host #{hst.to_s}") unless Cli.quiet
                restart(hst)
            end
        end
        return false
    end

    # Expect timeout in seconds. Blocking if nil.
    def recv(timeout = nil)
        opts = {"Match" => /.+/,
            "Timeout" => (timeout ? timeout : false),
            "FailEOF" => false
            }
        return nil if timeout and timeout < 1
        loop do
            begin
                hst = @host
                puts "waitfor(#{timeout.to_s})" if ENV['DEBUG']
                res = hst.waitfor(opts)
                puts "waitfor(#{timeout.to_s}) -> " + res.inspect if ENV['DEBUG']
                return res if res
            rescue Timeout::Error
                Log.info("CLI/telnet recv: Timeout while waiting for data") unless ((not ENV['DEBUG']) and (Cli.quiet or timeout))
                return nil if timeout
            rescue Exception => e
                Log.info("#{@id}: recv() restarting, caught #{e.to_s}") unless Cli.quiet
                restart(hst)
                #raise if closed?
            end
        end
    end

    def declare_master
        @host.write(Net::Telnet::IAC + Net::Telnet::DONT + Net::Telnet::DONT)
    end

    def declare_script
        @host.write(Net::Telnet::IAC + Net::Telnet::DO + Net::Telnet::DO)
    end

    private

    # Both inital startup, and subsequently restart when recv or send_str discover
    # that the host is dead. For that reason they must have stored the host object
    # in a local variable to hand to this function in case it need to be restarted.
    def restart(host_to_kill = nil)
        @host_mutex.synchronize do
            raise "Invalid telnet target: #{@target}" unless ((@target =~ /^telnet:([^:]+)(:(\d+))?$/) or @do_proxy)
            host, port = $1, ($2 ? $3.to_i : 23)
            if host_to_kill
                host_to_kill.close rescue nil
                # The host we used has already been replaced by aother thread calling
                # restart. Return unless the current host is dead.
                if (@host != host_to_kill)
                    return if (@host and not @host.sock.closed?)
                    @host.close if @host
                end
            end

            if @do_proxy
                proxy = TerminalServerController.new(@target)
                res = proxy.get_runfile_data(false) # Do not wait, only get data if exists
                if res and (runstate != :script) and (@do_proxy == "restart")
                    # Kill existing console proxy, if the topology requires it (and we have not been run by the harness).
                    Process.kill(9, res["pid"])
                    File.delete(proxy.runfile)
                    res = nil
                end
                if not res
                    cmd = "screen -S #{@id} -d -m #{File.dirname(__FILE__)}/telnet_server.rb #{@target}"
                    Log.info("#{@id}: Spawning new terminal server #{cmd}") unless Cli.quiet
                    system({"NONFORK" => "TRUE"}, cmd)
                    res = proxy.get_runfile_data
                end
                host, port = "localhost", res["port"]
            end
            Log.info("Telnet: Contacting #{host}:#{port}") if @debug
            @host = Net::Telnet::new("Host"    => host,
                                     "Port"    => port,
                                   # "Dump_log" => "telnet-log.txt",
                                     "Timeout" => 30)
            Log.info("#{id}: restart() got new @host #{@host.to_s} to #{host}:#{port.to_s}") unless Cli.quiet
            if @do_proxy
                case runstate
                when :framework
                    declare_master
                when :script
                    declare_script
                end
            end
        end
    end
end

class CliTelnetShimTransport < CliTransport
    def initialize(target)
    end

    # Based on something found at https://www.ruby-forum.com/topic/75391 with no license restrictions
    def parse_telnet(data)                # minimal Telnet
        data.gsub!(/([^\015])\012/, "\\1")  # ignore bare LFs
        data.gsub!(/\015\0/, "")            # ignore bare CRs
        data.gsub!(/\0/, "")                # ignore bare NULs

        while data.index("\377")            # parse Telnet codes
            if data.sub!(/(^|[^\377])\377[\375\376](.)/n, "\\1")
                # answer DOs and DON'Ts with WON'Ts
                send_data("\377\374#{$2}")
            elsif data.sub!(/(^|[^\377])\377[\373\374](.)/n, "\\1")
                # answer WILLs and WON'Ts with DON'Ts
                send_data("\377\376#{$2}")
            elsif data.sub!(/(^|[^\377])\377\366/n, "\\1")
                # answer "Are You There" codes
                send_data("Still here, yes.")
            elsif data.sub!(/(^|[^\377])\377\364/n, "\\1")
                # do nothing - ignore IP Telnet codes
            elsif data.sub!(/(^|[^\377])\377[^\377]/n, "\\1")
                # do nothing - ignore other Telnet codes
            elsif data.sub!(/\377\377/n, "\377")
                # do nothing - handle escapes
            end
        end
        data
    end
end

class CliTransportFactory
    def CliTransportFactory.build(target, options={})
        do_proxy = options.fetch(:do_proxy, false)
        return CliTelnetTransport.new(target, options) if do_proxy
        transport = case target
        when /^rs232:/
            CliRs232Transport.new(target, options)
        when /^telnet:/
            CliTelnetTransport.new(target, options)
        else
            raise CliException.new("Unknown transport type: #{target}")
        end

        return transport
    end
end

#
# CLI classes
#

class CliException < StandardError
end

class CliRedBootException < CliException
end

# Base class for CLI types. For ICLI, look further down.
#
# Common usage:
#
#    output = cli.cmd("some cli command here")
#    # maybe do something with output
#
#    cli.send_str("\r")    # send CR
#    output = cli.expect("some kind of output")
#    # maybe do something with output
#
#    cli.cmd_noout("command that must not generate output")
#
# Several functions take an option hash. The allowable values are:
#
#    :timeout => Fixnum                          - number of seconds to wait for expected output, default is Consts::CLI_DEFAULT_TIMEOUT
#    :yield_line_by_line => true/false(default)  - if a block is given: true => yield on a line-by-line basis;
#                                                  false => yield whenever a chunk of data has arrived
#
# Also note cmd_fuzz; it's sometimes quite useful for command stressing

class Cli
    attr_accessor :prompt
    attr_accessor :timeout
    attr_accessor :debug
    attr_accessor :id

    @@quiet        = false
    @@disable_fuzz = false

    def Cli.quiet=(val)
        @@quiet = val
    end

    def Cli.quiet
        return @@quiet
    end

    def Cli.disable_fuzz
        @@disable_fuzz
    end

    def Cli.disable_fuzz=(val)
        @@disable_fuzz = val
    end

    def initialize(target, options={})
        begin
            @debug     = false
            @target    = target
            @options = options
            @options[:id] = options.fetch(:id, "CLI")
            @transport = CliTransportFactory.build(@target, @options)
            @prompt  = /[#>]/
            @timeout = 5
#        rescue => msg
#            raise CliException.new("Cannot initialize CLI: #{msg}")
        end
    end

    def id=(val)
        @transport.id = val
    end

    def id
        return @transport.id
    end

    def close
        @transport.close
    end

    def alive?
        @transport.alive?
    end

    def declare_master
        Log.info("#{id}: Declare master")
        @transport.declare_master
    end

    def declare_script
        Log.info("#{id}: Declare script")
        @transport.declare_script
    end

    # Execute one or more commands and return the output (all RX data up to and including @prompt).
    # Raises exception if the prompt wasn't seen in time.
    def cmd(lines, options = {}, &block)
        prompt = options.fetch(:prompt, @prompt)
        if lines.kind_of?(String)
            lines = lines == "" ? [""] : lines.split("\n")
        end
        buf = ""
        opts = options.clone
        opts[:timeout] = opts[:timeout] || @timeout
        opts[:retry_prompt] = 10 if opts[:retry_prompt].nil?
        lines.each do |ln|
            @transport.flush unless options.fetch(:nonflush, false)
            send_str(ln + "\r")
            Log.info("CLI: #{ln}")

            request_prompt_cnt = 0
            echo = nil
            begin
                if request_prompt_cnt != 0
                    send_str("\r")
                end
                if opts.fetch(:expect_echo, true)
                    # Explicit wait for echo of that specific command, to get
                    # the response in sync.
                    echo = expect(/#{Regexp.quote(ln)}/, opts) unless echo
                    Log.info("#{id}.cmd(): got echo:#{echo.inspect}") if @debug
                    if echo
                        res = expect(prompt, opts, &block)
                        Log.info("#{id}.cmd(): got res:#{res.inspect}") if @debug
                        res = echo + res if res
                    end
                else
                    res = expect(prompt, opts, &block)
                    Log.info("#{id}.cmd(): got res:#{res.inspect}") if @debug
                end
                request_prompt_cnt += 1
            end while !res && request_prompt_cnt < opts[:retry_prompt]

            raise CliException.new("#{id}: Did not get prompt within timeout of #{opts[:timeout]} secs + #{request_prompt_cnt} retries") if !res
            buf += res
        end
        Log.info("#{id}.cmd(): returning #{buf.inspect}") if @debug
        buf
    end

    # Execute commands. Raise exception if there is output from the command.
    # Technically, we first get an echo line back, and we also get the command prompt after execution. This makes up
    # two lines, so we simply test if we get more than that.
    def cmd_noout(lines, options = {}, &block)
        if lines.kind_of?(String)
            lines = lines == "" ? [""] : lines.split("\n")
        end
        lines.each do |ln|
            res = cmd(ln, options, &block).split("\n")
            if res.length != 2
                # Accept stack port warning, eg:
                #% Notice: 10GigabitEthernet 1/3,4, 2/3,4 are stack interfaces, which can't be configured. All commands for these interfaces are silently ignored.
                tst = res[1..-2].all? do |l|
                    /^% Notice:\s.*\sare stack interfaces, which can't be configured. All commands for these interfaces are silently ignored\./.match(l) ||
                    /^\s*(\(\S*\))?#\s*(#{Regexp.quote(ln)})?\s*$/.match(l) ||
                    l.chomp == ""
                end
                raise CliException.new("#{id}: Unexpected output from command: <#{res[1].chomp}>") unless tst
            end
        end
        true
    end

    # "Fuzz" commands, typically for configuration. IMPORTANT: Does not expect output, similar to cmd_noout.
    #
    # Takes an array containing a mix of strings and flags.
    #
    # All strings are broken into lines; the flags work on the following lines in this manner:
    #
    #   :fuzz_no    - for configuration commands. Randomly chooses a line that's expanded to "line", "no line", "line", i.e. set/reset/set
    #   :fuzz_order - shuffles the ordering of the following lines
    #   :stop_fuzz  - disable both of the above
    #
    # It's possible to enable both :fuzz_no and :fuzz_order to shuffle the order of lines and the "no" behavior, but note that the three-line "no" sequence isn't affected
    #
    # The set of lines shuffled by :fuzz_order begins at the first line after :fuzz_order and continues until the next flag. If that flag isn't :stop_fuzz, a new set
    # of lines for shuffling begins there.
    #
    # Example:
    #     cmd_fuzz(["a1", "a2", "a3", :fuzz_no, "b1", "b2\nb3", :fuzz_order, "c1\nc2", "c3", :stop_fuzz, :fuzz_order, "d1\d2\d3", :stop_fuzz, "e1", "e2", "e3"])
    # Could result in something like this:
    #
    #   a1    - ordered
    #   a2
    #   a3
    #
    #   b1    - :fuzz_no => randomly select set/reset/set line, in this case for b2
    #   b2
    #   no b2
    #   b2
    #   b3
    #
    #   c3    - :fuzz_no is still in effect, c2 and c3 have 'no' forms, but :fuzz_order shuffles: c3 c1 c2
    #   no c3
    #   c3
    #   c1
    #   c2
    #   no c2
    #   c2
    #
    #   d2    - :stop_fuzz followed by :fuzz_order => shuffling without 'no' forms
    #   d1
    #   d3
    #
    #   e1    - :stop_fuzz => ordered
    #   e2
    #   e3

    def cmd_fuzz(lines, options = {}, &block)

        # Fuzzing globally disabled: Remove fuzz symbols from input

        if @@disable_fuzz
            lines = lines.flatten.find_all { |elem| !elem.kind_of?(Symbol) }
            lines = lines.map { |ln| ln.gsub(/^\s*((:fuzz_no|:fuzz_order|:stop_fuzz)(\s+|$))+/, '') }       # Kill string-embedded symbols
            return cmd(lines, options, &block)
        end

        # 'lines' may be an array of arrays of symbols+strings; options{:shuffle => true} will lead to the outer array being shuffled

        unless options[:shuffle].nil?
            raise "cmd_fuzz: Can only shuffle arrays, not #{lines.class}" unless lines.kind_of?(Array)
            lines.each { |chunk|
                raise "cmd_fuzz: Can only shuffle arrays, not #{chunk.class}" unless chunk.kind_of?(Array) or chunk.kind_of?(Symbol)
            }
            lines = lines.shuffle.map { |chunk| [:stop_fuzz] + chunk }
        end

        # The strings may contain fuzz symbols as text; convert to real symbols (e.g. ":fuzz_no foo bar" => [:fuzz_no, "foo bar"])

        lines = lines.kind_of?(String) ? [lines] : lines.flatten
        lines = lines.map { |chunk|
            if chunk.kind_of?(Symbol)
                chunk
            else
                c = []
                while (m = chunk.match(/(\s*)\:(fuzz_no|fuzz_order|stop_fuzz)(\s*)/))
                    c << m.pre_match if m.pre_match.strip != ""
                    c << $2.to_sym
                    chunk = $1 + $3 + m.post_match
                end
                c + [chunk]
            end
        }
        lines = lines.flatten

        fuzz_no = fuzz_order = false

        sequence = []       # Resulting sequence of commands after fuzzing
        acc      = []       # Accumulator

        lines.each do |ln|
            if ln.kind_of?(Symbol)
                case ln
                when :fuzz_no
                    fuzz_no = true
                when :fuzz_order
                    fuzz_order = true
                when :stop_fuzz
                    fuzz_no = fuzz_order = false
                end
                sequence += acc.shuffle
                acc       = []
                next
            end

            raise "Unexpected input for cmd_fuzz: '#{ln}', type #{ln.class}" unless ln.kind_of?(String)

            ln = ln.split("\n")

            if fuzz_no
                ln = ln.map do |x|
                    if !(x =~ /^(\s*no\s+|\s*$)/) && (rand(2) == 1) then
                        x =~ /^(\s*)(.*)/
                        [x, "#{$1}no #{$2}", x]
                    else
                        x
                    end
                end
            end

            if fuzz_order
                acc += ln
            else
                sequence += ln
            end
        end

        sequence += acc.shuffle

        sequence.flatten.each do |ln|
            out = cmd(ln, options, &block)
            res = out.split(/\n/)
            if res.length != 2
                n = (res.length > 3) ? 3 : -1
                raise CliException.new("#{id}: Unexpected output from command: #{res[1..n].inspect}")
            end
        end
        true
    end

    # Send a string, but don't wait for reply. It's up to the caller to use expect() afterwards, if relevant.
    def send_str(str)
        Log.info("CLI: TX: <#{str.chomp}>") if @debug
        @transport.send_str(str)
    end

    # Expect a pattern within a timeout. If a block is given, received data is yielded as it is received, either on a line-by-line basis
    # (options[:yield_line_by_line] == true) or on a chunk basis.
    def expect(regexp, options = {}, &block)
        raise "Bug! options must be a hash, got #{options.class}" unless options.kind_of?(Hash)
        raise RuntimeError.new("CLI expect pattern '#{regexp}' is a #{regexp.class} and not a regular expression") unless regexp.kind_of?(Regexp)
        t = options[:timeout] || @timeout
        Log.info("CLI: Expecting #{regexp}, timeout #{t}") if @debug
        latest = ""
        res = @transport.expect(regexp, t, options) do |str|
            Log.info("CLI: RX: <#{str}>") if @debug
            if block
                if options[:yield_line_by_line]
                    lines = latest + str
                    while lines =~ /^([^\n]*\n)/
                        matchdata = $~
                        line, lines = matchdata[0], matchdata.post_match
                        block.call(line)
                    end
                    latest = lines
                else
                    block.call(str)
                end
            end
        end
        block.call(latest) if options[:yield_line_by_line] && latest != ""
        res
    end

    # Match output from command against string containing lines of regular expressions.
    # See vtss_appl/erps/platform/test/erps-basic-test.rb for an example of use,
    # Notes:
    #   - Since the first line of output is usually an echo of the command line, start 'expected' with .* on the first line
    #   - Each line in 'expected' is treated as a regular expression. Thus, matching of characters also used in regular expressions
    #     requires that those characters are escaped with '\'. Pay attention here: If the 'expected' string is written with some
    #     sort of double-quotes like "this" or """this""", then you must double-escape! The reason is that Ruby will read "\-" as
    #     "escape minus, oh, that's just minus" and the regular expression isn't what you expect. So use "\\-" instead; Ruby will
    #     read that as "escape backslash, that just a backslash. And then a minus", meaning that the regular expression will indeed
    #     see the escaped minus.
    #   - Each line is matched from left to right, and as soon as the regular expression is satisfied, matching for that line stops.
    #     This is usually no problem, but if there is a desire to ensure that nothing follows on the line, use '$' at the end:
    #     "  foo bar baz$"
    #   - Be careful about spaces at the end of lines in 'expected'. Those spaces will be matched against, but if they e.g. showed up due
    #     to the code editor used to write the string then the matching will fail.
    #
    def verify_output(output, expected, flexible_horiz_spacing = true)
        # escapes = [ ['(', '\\('], [')', '\\)'] ]      # "Escape" some regexp constructs that we don't need; makes it easier for the user
        output = output.split("\n") if output.kind_of?(String)
        expected = expected.split("\n").map do |line| line.gsub(/\s+/, '\s+') end if flexible_horiz_spacing
        while output != []  &&  expected != []
            o = output.shift.chomp
            e = "^" + expected.shift
            # escapes.each do |pat, sub| e.gsub!(pat, sub) end
            (re = Regexp.new(e)) rescue raise "Test bug: Invalid regular expression: <#{e}>"
            raise "Unexpected output: <#{o}> did not match #{re.to_s}" unless o =~ re
        end
        raise "Incomplete output: Missing #{expected.length} line(s); first is <#{expected[0]}>" unless expected == []
        true
    end

end

