// Copyright (c) 2004-2020 Microchip Technology Inc. and its subsidiaries.
// SPDX-License-Identifier: MIT

= Getting started

== Getting started

The easiest and best way to get started with the MESA library, is to start using
it. MESA as such is a C library, but the MESA packet includes a demo application,
and scripts to build a complete bootable firmware image including a
Linux root file system, demo application and the MESA library.

The MESA packet includes both sources and binaries. Binaries make it easy to
load the pre-build code on a reference system and explore the demo application.
But most users of the MESA library will eventually need to build their own
application, or integrate MESA into an existing application. Doing this requires
compiling the sources.

This document will cover how to prepare a development system, build the sources,
load the binaries, and start the MESA demo application.

Users that are in a hurry, and already has a reference system can skip the steps
to compile the sources, and instead using one of the binary images.

== Pre-requests and preparations

In order to follow this getting started guide, a version of the MESA packet and a
reference board is needed.

Further more, to build and load the MESA library and demo application a Linux
development machine with root access is needed. This guide is using a Ubuntu
Server version 18.04 with 8G of memory. Other distributions does also work, but
they are expected to need other dependencies not documented here.

When loading the firmware, this guide assumes that the Linux development machine
is located at the same network as the reference board.

=== Installing basic SW dependencies

The first step is to install a couple of host tools needed by MESA. The packet
manager and the name of the specific packets differs from distributions to
distribution. Here are the instructions on how to do this on Ubuntu 18:

----
sudo apt-get install cmake cmake-curses-gui build-essential ruby ruby-parslet libjson-c-dev
----

Next we need a folder called `mscc` in `/opt` where the toolchains
and BSP will be installed as explained later in the guide.

----
sudo mkdir -p /opt/mscc
----

==== Install and setup tftp server

In order to load the SW to the reference board, we need a tftp server. If a tftp
server is already available on your network, then you may skip this step. If
not, then it can be installed using the instructions below:

----
sudo apt-get install tftpd-hpa
sudo chmod 777 /var/lib/tftpboot/
----

== Extracting the sources

The first step is to extract the MESA packet:

----
$ tar xf mesa-<version>.tar.gz
$ cd mesa-<version>
----

== Copy a binary image to the tftp folder

To confirm that the boards are working and compatible with a given firmware
image, it is a good idea to start loading one of the binary images as a first
step.

To do this copy one of the image files from `./bin/<arch>/mesa/demo/` to the
tftp server. Example:

----
$ cp bin/mipsel/mesa/demo/mipsel_vsc7514.mfi /var/lib/tftpboot/
----

To try out the binary image, skip the instructions to build, and go directly to
the section on firmware loading.

== Create a CMake project (and download BSP and toolchain)

To build the sources a CMake project is needed. The easiest way to create a
CMake project is to use the `./.cmake/create_cmake_project.rb` script:

----
$ ./.cmake/create_cmake_project.rb
Usage: create_cmake_project <preset name> [output-folder]

Valid presets:
    mipsel
    mipsel-debug
    arm64
    arm64-debug
    arm64-asan
    arm
    arm-debug
    x86
----

Lets prepare a project for MIPS little endian based targets:

----
$ ./.cmake/create_cmake_project.rb mipsel
----

If the needed BSP and/or toolchain is missing, then the script will complain
about this and provide instructions on how to install these components. This is
expected to be the case the first time running this command on a new release.

Here the scripts complains about the BSP is missing:

----
$ ./.cmake/create_cmake_project.rb mipsel
Please install the BSP: /opt/mscc/mscc-brsdk-mipsel-2020.02.3-310

This may be done by using the following command:
sudo sh -c "mkdir -p /opt/mscc && wget -O- <URL> | tar -xz -C /opt/mscc/"
----

Paste in the command printed at the screen (with the expanded URL), and complete
the BSP installation.

Run the script again, this time it detects that the toolchain is missing:

----
$ ./.cmake/create_cmake_project.rb mipsel
Please install the toolchain: mscc-toolchain-bin-2020.02.3-085 into /opt/mscc/

This may be done by using the following command:
sudo sh -c "mkdir -p /opt/mscc && wget -O- <URL> | tar -xz -C /opt/mscc/"
----

Paste in the command printed at the screen (with the expanded URL), and complete
the toolchain installation.

Run the command again:

----
$ ./.cmake/create_cmake_project.rb mipsel
mkdir -p build-mipsel
ln -s /opt/mscc/mscc-brsdk-mipsel-<version>/mipsel-mips32r2-linux-gnu/smb/x86_64-linux/bin/cmake cmake
./cmake -DCMAKE_TOOLCHAIN_FILE=/opt/mscc/mscc-brsdk-mipsel-<version>/mipsel-mips32r2-linux-gnu/smb/x86_64-linux/usr/share/buildroot/toolchainfile.cmake -DCMAKE_BUILD_TYPE=Release ..
-- The C compiler identification is GNU 8.3.0
-- The CXX compiler identification is GNU 8.3.0
-- Check for working C compiler: /opt/mscc/mscc-brsdk-mipsel-<version>/mipsel-mips32r2-linux-gnu/smb/x86_64-linux/usr/bin/mipsel-linux-gcc
-- Check for working C compiler: /opt/mscc/mscc-brsdk-mipsel-<version>/mipsel-mips32r2-linux-gnu/smb/x86_64-linux/usr/bin/mipsel-linux-gcc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /opt/mscc/mscc-brsdk-mipsel-<version>/mipsel-mips32r2-linux-gnu/smb/x86_64-linux/usr/bin/mipsel-linux-g++
-- Check for working CXX compiler: /opt/mscc/mscc-brsdk-mipsel-<version>/mipsel-mips32r2-linux-gnu/smb/x86_64-linux/usr/bin/mipsel-linux-g++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Project name          = vtss_api
--   Type                = Release
--   c_flags             = -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 -Wall -Wno-array-bounds -fasynchronous-unwind-tables -std=c99 -D_POSIX_C_SOURCE=200809L -D_BSD_SOURCE -D_DEFAULT_SOURCE -O3 -DNDEBUG
--   EXE_LINKER_FLAGS    =
--   shared_linker_flags =
-- Looking for include file endian.h
-- Looking for include file endian.h - found
-- Looking for include file asm/byteorder.h
-- Looking for include file asm/byteorder.h - found
-- CMAKE_TOOLCHAIN_FILE='/opt/mscc/mscc-brsdk-mipsel-<version>/mipsel-mips32r2-linux-gnu/smb/x86_64-linux/usr/share/buildroot/toolchainfile.cmake'
-- Configuring done
-- Generating done
-- Build files have been written to: ./build-mipsel
----

This time all the dependencies was found, and the CMake project has not been
created in the `./build-mipsel` folder. Enter the folder and continue from here:

----
cd ./build-mipsel
----

NOTE: The BSP also provides UBoot for the various targets. UBoot for the MIPS
based boards can be found in
`/opt/mscc/mscc-brsdk-mipsel-<version>/mipsel-mips32r2-linux-uclibc/<board>/`.


== Select the image(s) to build

We now have CMake project configured to use the BSP and cross-tool chain to
build binaries for the MIPS, but no targets has been enabled.

Make sure to `cd` to the newly created build folder.

The CMake project allow you to select what targets to build. By default nothing
is selected. The various projects includes many targets, and some naming
conventions are used to make it easier to navigate.

Generally the `vscXXXX` number is included in all targets to indicate what
device a given target supports.

In the various CMake projects, the following categories of targets can be
found:

. Library targets. These are not bootable, it is just libraries supporting a
  given chip, and must be combined with an actual application, root file system
  and kernel to provide a functional system.
.. `vscXXXX` These are shared libraries for a given `vsc` chip ID.
.. `vscXXXX_static` These are static libraries for a given `vsc` chip ID.

. Bootable demo images. These targets will generate a complete firmware image
  including kernel, root file system, and the MESA Demo application. These are
  the images used in this getting started article.
.. `mipsel_vscXXXX` This is a MFI image which is the default image type on
   MIPS based targets.
.. `fit_vscXXXX` This is the standard UBoot FIT (extension name is
   `.itb`) image which is used on the ARM/ARM64 based targets.

. Pure application
.. `app_vscXXXX` This is the MESA application build along with the needed
   library. This does not include the kernel and the root file system, which
   needs to come from elsewhere.

To see all the targets defined in the project use the `./cmake .. -LAH` command,
or the GUI tool `ccmake ..`.

HINT: Use the `./cmake .. -LAH` command in combination with `grep` to only see
targets matching the decides you are interested in.

NOTE: We are generally using the `./cmake` symlink instead of the system
installation of CMake. This is a symlink to cmake provided by the BSP. The
advantage of this, is that we can then ensure that same version of CMake is
always used.

In this example we will build the complete demo project for the Ocelot vsc7514.
To do this, we will grep for 7514 in the available options:

----
$ ./cmake .. -LAH | grep 7514
app_vsc7514:BOOL=OFF
mfi_vsc7514_pcb120:BOOL=on
mfi_vsc7514_pcb123:BOOL=OFF
// Build the API for 7514 (vsc7514)
vsc7514:BOOL=OFF
// Build the static API for 7514 (vsc7514)
vsc7514_static:BOOL=OFF
----

As we are interested in a bootable firmware we need either a `fit`/`itb` or
`mfi` image. In this case we want the `mfi_vsc7514_pcb120` target. To enable this use
the following command:

----
$ ./cmake .. -Dmfi_vsc7514_pcb120=on
-- Project name          = vtss_api
--   Type                = Release
--   c_flags             = -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 -Wall -Wno-array-bounds -fasynchronous-unwind-tables -std=c99 -D_POSIX_C_SOURCE=200809L -D_BSD_SOURCE -D_DEFAULT_SOURCE -O3 -Wall -Wno-array-bounds -fasynchronous-unwind-tables -std=c99 -D_POSIX_C_SOURCE=200809L -D_BSD_SOURCE -D_DEFAULT_SOURCE -O3 -DNDEBUG
--   EXE_LINKER_FLAGS    =
--   shared_linker_flags =
-- CMAKE_TOOLCHAIN_FILE='/opt/mscc/mscc-brsdk-mipsel-2002.02.3-310/mipsel-mips32r2-linux-gnu/smb/x86_64-linux/usr/share/buildroot/toolchainfile.cmake'
-- Configuring done
-- Generating done
-- Build files have been written to: /tmp/mesa-v2019.06-217-g9c57e1c@master/build-mipsel
----

== Building the SW

Now that the project is configured, we just need to build it. This is the only
step which needs to be repeated when the sources are changed.

Use the normal make command to build (the `-jN` options specify how many cores
to use).

----
$ make -j12
....
Scanning dependencies of target app_vsc7514
[100%] Building C object mesa/demo/CMakeFiles/app_vsc7514.dir/main.c.o
[100%] Linking C executable mesa-demo-vsc7514
[100%] Built target app_vsc7514
Scanning dependencies of target mipsel_vsc7514_mfi
[100%] Generating app_vsc7514.tar
[100%] Generating mipsel_vsc7514.mfi
[100%] Built target mipsel_vsc7514_mfi
----

After a while, the build will be done, and the resulting image can be found in
`./mesa/demo`. Lets copy this to the tftp server folder.

----
$ cp mesa/demo/mipsel_vsc7514.mfi /var/lib/tftpboot/.
----


== Loading firmware image over network from UBoot

UBoot is being used to load the SW over the network via TFTP and into memory.
The system can then boot from memory.

Connect a terminal to the reference board, open your serial terminal client
(`minicom`, `picocom`, `teraterm`, `putty`), power up the board, and break the
boot process in the UBoot console. This is an example of booting an Ocelot
board, and breaking it into UBoot.

----
U-Boot 2019.07-rc2 (Jul 09 2019 - 14:30:28 +0200)

MSCC VCore-III MIPS 24Kec
Model: Ocelot PCB123 Reference Board
DRAM:  512 MiB
Loading Environment from SPI Flash... SF: Detected mx25l25635e with page size
256 Bytes, erase size 64 KiB, total 32 MiB
OK
In:    serial@100000
Out:   serial@100000
Err:   serial@100000
Net:
Warning: switch@1010000 (eth0) using random MAC address - 0a:01:c5:af:05:e1
eth0: switch@1010000
Hit any key to stop autoboot:  0
ocelot #
----

=== Configure network and load SW to memory

If a DHCP server is being used at the network, then this is simply a matter of
issuing the `dhcp` command:

----
ocelot # dhcp
BOOTP broadcast 1
BOOTP broadcast 2
BOOTP broadcast 3
DHCP client bound to address 10.99.10.10 (1003 ms)
Using switch@1010000 device
TFTP from server 10.99.10.1; our IP address is 10.99.10.10
ocelot #
----

If static IP configuration is desirable, then set the `ipaddr`, `netmask` and
`gatewayip` accordingly:

----
setenv ipaddr 10.99.10.10
setenv gatewayip 10.99.10.1
setenv netmask 255.255.255.0
----

NOTE: To make the environment settings persistent, use the `saveenv` command.

After network configuration is completed, check that we have the needed
connectivity:

----
ocelot # ping 10.99.10.1
Using switch@1010000 device
host 10.99.10.1 is alive
ocelot #
----

Final step is to load the SW into memory. To do this the `tftp` command is used.
Remember to copy the firmware image into the tftp folder, and use the correct IP
address of the tftp server and firmware filename (this example uses `10.99.10.1`
as tftp server, and `firmware.ext` firmware file, replace with IP of your TFTP
server, and actual file name of the firmware).

----
ocelot # tftp ${loadaddr} 10.99.10.1:firmware.ext
Using switch@1010000 device
TFTP from server 10.99.10.1; our IP address is 10.99.10.10
Filename 'mipsel_vsc7415.mfi'.
Load address: 0x81000000
Loading: #################################################################
         #################################################################
         #################################################################
         #################################################################
         #################################################################
         #################################################################
         #################################################################
         ###################
         11.1 MiB/s
done
Bytes transferred = 6953696 (6a1ae0 hex)
ocelot #
----

=== Booting the firmware image

Depending on image type and board, the steps to actually boot the image are
slightly different.

Two different image types are being used, either the `mfi` images which is the
default image type used in WebStaX on the MIPS based targets, and then we have
`fit` images (with extension `itb`) which is a standard UBoot image type.

New ARM based designs only uses `fit`/`itb` images. MIPS targets can do both,
but the default is still `mfi`.


==== Booting `mfi` images

To boot a `mfi` image, use the `bootmfi` command like this:

----
ocelot # bootmfi ${loadaddr}
MD5 signature validated   Uncompressing Kernel Image ... OK
   Loading Ramdisk to 9f8db000, end 9fdb9000 ... OK
linux_env_set setting memsize=512
linux_env_set setting flash_start=0x00000000
linux_env_set setting flash_size=0x0
Starting syslogd: OK
Starting klogd: OK
read-only file system detected...done
Starting network: OK
Starting ntpd: OK
No persistent location to store SSH host keys. New keys will be
generated at each boot. Are you sure this is what you want to do?
Starting dropbear sshd: OK

Welcome to SMBStaX
vcoreiii login:
----

==== Booting `fit`/`itb` images

`fit` images may optional include multiple device tree configurations. The
current loaded image can be inspected using the `iminfo` like this:

----
=> iminfo ${loadaddr}

## Checking Image at 40000000 ...
   FIT image found
   FIT description: Image file for the MESA SDK Demo on target fireant
    Image 0 (kernel)
     Description:  aarch64 Linux kernel
     Type:         Kernel Image
     Compression:  gzip compressed
     Data Start:   0x400000d8
     Data Size:    2575726 Bytes = 2.5 MiB
     Architecture: AArch64
     OS:           Linux
     Load Address: 0x00080000
     Entry Point:  0x00080000
    Image 1 (ramdisk)
     Description:  ramdisk
     Type:         RAMDisk Image
     Compression:  uncompressed
     Data Start:   0x40274ee8
     Data Size:    5152768 Bytes = 4.9 MiB
     Architecture: AArch64
     OS:           Linux
     Load Address: 0x02000000
     Entry Point:  unavailable
    Image 2 (fdt)
     Description:  Flattened Device Tree blob
     Type:         Flat Device Tree
     Compression:  uncompressed
     Data Start:   0x4075ef88
     Data Size:    10443 Bytes = 10.2 KiB
     Architecture: AArch64
     Load Address: 0x20000000
    Default Configuration: 'fireant'
    Configuration 0 (fireant)
     Description:  Boot Linux kernel
     Kernel:       kernel
     Init Ramdisk: ramdisk
     FDT:          fdt
## Checking hash(es) for FIT Image at 40000000 ...
   Hash(es) for Image 0 (kernel):
   Hash(es) for Image 1 (ramdisk):
   Hash(es) for Image 2 (fdt):
----

In the output above we see an image containing a `kernel`, `ramdisk`, `ftd`
(device tree). These 3 component is grouped in a configuration called `fireant`.

To boot the `fit` image with a given configuration use the `bootm <addr>:<conf>`
command like this:

----
# bootm ${loadaddr}#fireant
----


==== Additional instructions for BeagleBone

If the `arm` architecture is selected when creating the CMake project, then it
is possible to build images for a beaglebone. Beaglebone uses a fit image,
requires altering the `bootargs` before booting. Example:

Lets start by building a fit image for the beagle bone, with the MESA demo
application for VSC7514.

----
$ ./.cmake/create_cmake_project.rb arm
$ cd build-arm
$ ./cmake -Dfit_bbb_vsc7514=on ..
$ make -j12
----

Next step is booting it. Got to a UBoot prompt on the BeagleBone, download the
image over network and boot it like this:

----
# tftp ${loadaddr} 10.99.10.1:armv7_vsc7514.itb
# setenv bootargs 'console=ttyO0,115200n8 root=/dev/ram0 ip=dhcp rw loglevel=0'
# bootm
----

Make sure that the BeagleBone is correctly connected to the Ocelot board. A
connector board exist to do this.

== Persisting firmware image in flash from UBoot

Depending on the board, there might be several storage options,
depending on image size and performance requirements.

* `NOR` flash
* `NAND` flash
* `eMMC` flash

`NOR` flash is available on all platforms. Depending on board type,
the size may be more or less restricted. On some boards it is as low
as 16 Mb, which requires additional software storage on `NAND`. The
`NOR` flash also holds the boot-loader.

`NAND` typically has larger capacity than `NOR`, starting at 128 Mb
and up. The system cannot boot from `NAND`, which is why it is used in
conjunction with `NOR`.

`eMMC` is available on SparX5(i) boards. It is currently the default for
PCB135 boards, but can be enabled for other boards (PCB134) as
well. `eMMC` provides superior performance compared to `NAND`, and
also has higher capacity.

Depending on the `NOR` capacity and the image size, it may be possible
to configure a board to solely use `NOR`. This option is referred to
as _NOR only_.

Depending on how you want to boot the firmware, you will need to use
one of several image types:

* `MFI`: This is a proprietary image format, which is used for `NOR`
  in conjunction with `NAND`. It is typically used on the MIPS-based boards.

* `FIT`: This is a standard U-Boot image format, which is used for
  _NOR only_ or network boot. It can be used on all boards running
  U-Boot. (It uses the `.itb` suffix, which is why it sometimes also
  is called `ITB`).

* `ubifs`: This image type is used for SparX5(i)-based boards using
  `NAND` for storage. It is a standard Linux filesystem image format,
  suitable for this storage type.

* `ext4.gz`: This image type is used for SparX5(i)-based boards using
  `eMMC` for storage. It is a standard Linux filesystem image format,
  suitable for this storage type.

=== Flashing boards using U-Boot

When preparing a board for flashing, make sure that:

1. You have the latest U-Boot installed. (And have booted it!).
2. You have reset the U-Boot environment. Do so by the following steps:
   * `env default -a`
   * `env save`

U-boot typically contain pre-coded command sequences in the
environment, which is why it is crucial to reset this to default
_after_ upgrading.

==== Flashing MIPS boards

The MIPS-based boards all use `NOR` for storing software images, and
has a general-purpose filesystem in `NAND`. The `NAND` filesystem is
not accessibly by the boot loader.

The partitions are defined by default to match each board, and do
typically not need to be changed:

----------------------
ocelot # sf probe
SF: Detected mx25l25635e with page size 256 Bytes, erase size 64 KiB, total 32 MiB
ocelot # mtd li
List of MTD devices:
* nor0
  - type: NOR flash
  - block size: 0x10000 bytes
  - min I/O: 0x1 bytes
  - 0x000000000000-0x000002000000 : "nor0"
          - 0x000000000000-0x000000100000 : "UBoot"
          - 0x000000100000-0x000000140000 : "Env"
          - 0x000000140000-0x000000180000 : "Env.bk"
          - 0x000000180000-0x000001080000 : "linux.bk"
          - 0x000001080000-0x000001f80000 : "linux"
----------------------

The boards can be flashed in a straightforward method. Note if you are running
WebStaX, then you will need to use the "bringup" configuration images on boards
with small capacity.

* `env set nor_image somepath/image.itb`
* `run nor_dlup`

As seen below:

----------------------
ocelot # env set nor_image somepath/istax_ocelot_10.itb
ocelot # run nor_dlup
BOOTP broadcast 1
BOOTP broadcast 2
DHCP client bound to address 10.10.137.57 (254 ms)
Using switch@1010000 device
TFTP from server 10.10.137.100; our IP address is 10.10.137.57
Filename 'somepath/istax_ocelot_10.itb'.
Load address: 0x81000000
Loading: #################################################################
         #################################################################
         ...
         #################################################################
         ##################################
done
Bytes transferred = 14481784 (dcf978 hex)
SF: Detected mx25l25635e with page size 256 Bytes, erase size 64 KiB, total 32 MiB
device 0 offset 0x180000, size 0xdcf978
14481784 bytes written, 0 bytes skipped in 116.21s, speed 128157 B/s
ocelot #
----------------------

After this, the default `bootcmd` being `run nor_boot` should start
the firmware installed.

==== Flashing SparX5(i) boards

In the default state, SparX5(i) boards are configured as follows:

* PCB134: `NAND` boot.
* PCB135: `eMMC` boot.

Due to the large `NOR` device mounted by default (mx66, 128 Mb), it is
also possible to configure this device for _NOR only_ boot.

===== Flashing SparX5(i) for `NAND` boot

If you have installed the non-`eMMC` version of U-Boot, the board is
configured for booting the application from `NAND` by default. You
only have to download the `ubifs` image and write the image to `NAND`.

The default flash layout used is:

----------------------
=> mtd li
List of MTD devices:
* nor0
 - type: NOR flash
 - block size: 0x1000 bytes
 - min I/O: 0x1 bytes
 - 0x000000000000-0x000008000000 : "nor0"
         - 0x000000000000-0x000000100000 : "UBoot"
         - 0x000000100000-0x000000140000 : "Env"
         - 0x000000140000-0x000000180000 : "Env.bk"
* spi-nand0
 - device: spi-nand@e
 - parent: spi-master@600104000
 - driver: spi_nand
 - type: NAND flash
 - block size: 0x20000 bytes
 - min I/O: 0x800 bytes
 - OOB size: 64 bytes
 - OOB available: 62 bytes
 - 0x000000000000-0x000010000000 : "spi-nand0"
         - 0x000000000000-0x000004000000 : "Boot0"
         - 0x000004000000-0x000008000000 : "Boot1"
         - 0x000008000000-0x000010000000 : "rootfs_data"
----------------------
 
Use the commands below to download and flash the `NAND`
partition. (The `nand_cur` environment variable control whether
`Boot0` or `Boot1` partitions is used.)

* `env set nand_image somepath/image.ubifs`
* `run nand_dlup`

The flash process can look like this:

----------------------
=> env set nand_image somepath/new.ubifs
=> run nand_dlup
...
TFTP from server 10.10.137.100; our IP address is 10.10.137.22
Filename 'somepath/new.ubifs'.
Load address: 0x740000000
Loading: #################################################################
         #################################################################
         #################################################################
         ...
         #################################################################
         #################################################################
         #################################################################
         ###########################################
         2.6 MiB/s
done
Bytes transferred = 27172864 (19ea000 hex)
SF: Detected mx66l1g45g with page size 256 Bytes, erase size 4 KiB, total 128 MiB
Erasing 0x00000000 ... 0x03ffffff (512 eraseblock(s))
ubi0: default fastmap pool size: 25
ubi0: default fastmap WL pool size: 12
ubi0: attaching mtd5
ubi0: scanning is finished
ubi0: empty MTD device detected
ubi0: attached mtd5 (name "Boot0", size 64 MiB)
ubi0: PEB size: 131072 bytes (128 KiB), LEB size: 126976 bytes
ubi0: min./max. I/O unit sizes: 2048/2048, sub-page size 2048
ubi0: VID header offset: 2048 (aligned 2048), data offset: 4096
ubi0: good PEBs: 512, bad PEBs: 0, corrupted PEBs: 0
ubi0: user volume: 0, internal volumes: 1, max. volumes count: 128
ubi0: max/mean erase counter: 0/0, WL threshold: 4096, image sequence number: 0
ubi0: available PEBs: 466, total reserved PEBs: 46, PEBs reserved for bad PEB handling: 40
No size specified -> Using max size (59170816)
Creating dynamic volume rootfs of size 59170816
27172864 bytes written to volume rootfs
----------------------

After this, the default `bootcmd` being `run nand_boot` should start
the firmware installed.

===== Flashing SparX5(i) for `eMMC` boot

If you have installed the `eMMC` version of U-Boot, the board is
configured for booting the application from `eMMC` by default.

But before flashing you have to partion the `eMMC` memory device
itself, and save the generated GUID to the environment.

 * `run mmc_format`

As shown below. `mmc part` will show the layout.

----------------------
=> run mmc_format
GUID Partition Table Header signature is wrong: 0x0 != 0x5452415020494645
...
success!
Writing GPT: success!
Saving Environment to SPI Flash... SF: Detected mx66l1g45g with page size 256 Bytes, erase size 4 KiB, total 128 MiB
Erasing SPI flash...Writing to SPI flash...done
Valid environment: 1
OK
=> mmc part

Partition Map for MMC device 0  --   Partition Type: EFI

Part    Start LBA       End LBA         Name
        Attributes
        Type GUID
        Partition GUID
  1     0x00000022      0x00200021      "Boot0"
        attrs:  0x0000000000000000
        type:   0fc63daf-8483-4772-8e79-3d69d8477de4
        type:   linux
        guid:   fb861d82-da0c-4d6a-b902-c3ab5fb004ba
  2     0x00200022      0x00400021      "Boot1"
        attrs:  0x0000000000000000
        type:   0fc63daf-8483-4772-8e79-3d69d8477de4
        type:   linux
        guid:   4d15ad76-af36-4f54-8a7e-1bfbcbe18c0c
  3     0x00400022      0x00700021      "Data"
        attrs:  0x0000000000000000
        type:   0fc63daf-8483-4772-8e79-3d69d8477de4
        type:   linux
        guid:   28dcfed4-35a9-40e0-a607-e85164139971
----------------------

With the eMMC formatted, you can now download `ext4.gz` image and
write it to the `eMMC` device. The `mmc_image` environment parameter
controls the image filename to download.

* `env set mmc_image somepath/image.ext4.gz`
* `run mmc_dlup`

This could look like this:

----------------------
=> env set mmc_image somepath/new.ext4.gz
=> run mmc_dlup
...
Using switch@0 device
TFTP from server 10.10.137.100; our IP address is 10.10.137.62
Filename 'somepath/new.ext4.gz'.
Load address: 0x740000000
Loading: #################################################################
         #################################################################
         #################################################################
         #################################################################
         ...
         #################################################################
         #####################
         6.6 MiB/s
done
Bytes transferred = 19072717 (12306cd hex)
Uncompressed size: 53059584 = 0x329A000
MMC write: dev # 0, block # 34, count 103632 ... 103632 blocks written: OK
----------------------

After this, the default `bootcmd` being `run mmc_boot` should start
the firmware installed.

===== Flashing SparX5(i) for `NOR` boot

Before flashing the board, the `NOR` flash must first be partitioned.

Do so by executing `run nor_only` at the U-Boot prompt.

------------------------------
=> run nor_only
Saving Environment to SPI Flash... Erasing SPI flash...Writing to SPI flash...done
Valid environment: 1
OK
=> mtd list
List of MTD devices:
* nor0
 - type: NOR flash
 - block size: 0x1000 bytes
 - min I/O: 0x1 bytes
 - 0x000000000000-0x000008000000 : "nor0"
         - 0x000000000000-0x000000100000 : "UBoot"
         - 0x000000100000-0x000000140000 : "Env"
         - 0x000000140000-0x000000180000 : "Env.bk"
         - 0x000000180000-0x000001580000 : "linux"
         - 0x000001580000-0x000002980000 : "linux.bk"
         - 0x000002980000-0x000004980000 : "rootfs_data"
...
------------------------------

The `nor_parts` environment variable is used to subdivide the `NOR`
flash. If you have other capacity requirements, you can edit/change
the `nor_parts` variable _before_ running `nor_only`.

Once you have partitioned the `NOR`, download the `FIT` image for your
build and use the following commands to flash the device:

* `env set nor_image somepath/image.itb`
* `run nor_dlup`

For example:

-------------------------------
=> env set nor_image somepath/image.itb
=> run nor_dlup
...
Using switch@0 device
TFTP from server 10.10.137.100; our IP address is 10.10.137.12
Filename 'somepath/image.itb'.
Load address: 0x740000000
Loading: #################################################################
         #################################################################
         ...
         #################################################################
         #################################################################
         #################################################################
         #########################################################
         1.5 MiB/s
done
Bytes transferred = 15786816 (f0e340 hex)
SF: Detected mx66l1g45g with page size 256 Bytes, erase size 4 KiB, total 128 MiB
device 0 offset 0x180000, size 0xf0e340
11989824 bytes written, 3796992 bytes skipped in 142.438s, speed 113574 B/s
-------------------------------

After this, the default `bootcmd` being `run nor_boot` should start
the firmware installed.


== Starting MESA Demo

When the system boots, you will need to login to the Linux terminal. Login as
the `root` user with no password:

----
Welcome to SMBStaX
vcoreiii login: root
----

We now have a normal Linux command line interface. Where we can start the MESA
demo application using the command `mesa-demo`:

----
$ mesa-demo
----

This will run in the background as a daemon in the background, and allow the
`mesa-cmd` to issue commands.

To see the list of valid commands use the `mesa-cmd` with no argument.

----
$ mesa-cmd
# mesa-demo
# mesa-cmd
Available Commands:

Help
Exit
IP Status
MAC Add <mac_addr> <port_list> [<vid>]
MAC Agetime [<age_time>]
MAC Delete <mac_addr> [<vid>]
MAC Dump
MAC Flush
MAC Lookup <mac_addr> [<vid>]
Port Flow Control [<port_list>] [enable|disable]
Port MaxFrame [<port_list>] [<max_frame>]
Port Mode [<port_list>] [10hdx|10fdx|100hdx|100fdx|1000fdx|2500|5g|10g|25g|auto]
Port NPI [<port_no>] [enable|disable]
Port State [<port_list>] [enable|disable]
Port Statistics [<port_list>] [clear|packets|bytes|errors|discards]
Test [<test_no>]
VLAN Add <vid> <port_list>
VLAN Delete <vid>
VLAN Filter [<port_list>] [enable|disable]
VLAN Frame [<port_list>] [all|tagged|untagged]
VLAN PVID [<port_list>] [<vid>]
VLAN Type [<port_list>] [unaware|c-port|s-port]
VLAN UVID [<port_list>] [all|none|pvid]
Warm Start
call <method> <params>
Debug API [<layer>] [<group>] [<port_list>] [full] [clear] [action]
[<act_value>]
Debug Chip ID
Debug I2C Read <port_list> <i2c_addr> <addr> [<count>]
Debug I2C Write <port_list> <i2c_addr> <addr> <value>
Debug MMD Read <port_list> <mmd_list> <mmd_addr>
Debug MMD Write <port_list> <mmd_list> <mmd_addr> <value>
Debug Management [include|exclude]
Debug PHY Read <port_list> <addr_list> [<page>]
Debug PHY Write <port_list> <addr_list> <value> [<page>]
Debug Port Polling [enable|disable]
Debug Sym Query <word128>
Debug Sym Read <word128>
Debug Sym Write <word128> <value32>
Debug Trace [<module>] [<group>] [off|error|info|debug|noise]
Debug board dump
Debug phy scan
Debug sfp dump
----

== MESA Command Examples

Get help on the port state command:

----
# mesa-cmd port state help
Description:
------------
Set or show the port administrative state.

Syntax:
-------
Port State [<port_list>] [enable|disable]

Parameters:
-----------
<port_list>: Port list, default: All ports
enable     : Enable
disable    : Disable
(default: Show mode)
----

Lets check the port status:

----
# mesa-cmd port state
Port  State     Mode    Flow Control  Rx Pause  Tx Pause  MaxFrame  Link
----  --------  ------  ------------  --------  --------  --------  --------
1     Enabled   Auto    Enabled       Enabled   Enabled   1518      1Gfdx
2     Enabled   Auto    Enabled       Enabled   Enabled   1518      1Gfdx
3     Enabled   1Gfdx   Disabled      Disabled  Disabled  1518      Down
4     Enabled   1Gfdx   Disabled      Disabled  Disabled  1518      Down
5     Enabled   1Gfdx   Disabled      Disabled  Disabled  1518      Down
6     Enabled   1Gfdx   Disabled      Disabled  Disabled  1518      1Gfdx
7     Enabled   10Gfdx  Disabled      Disabled  Disabled  1518      Down
8     Enabled   10Gfdx  Disabled      Disabled  Disabled  1518      Down
9     Enabled   Auto    Enabled       Enabled   Enabled   1518      1Gfdx
#
----

Get help on the port statistics command:

----
# mesa-cmd port stati help
Description:
------------
Show port statistics.

Syntax:
-------
Port Statistics [<port_list>] [clear|packets|bytes|errors|discards]

Parameters:
-----------
<port_list>: Port list, default: All ports
clear      : Clear port statistics
packets    : Show packet statistics
bytes      : Show byte statistics
errors     : Show error statistics
discards   : Show discard statistics
(default: Show all port statistics)
----

Show packet counters for port 1-8:

----
# mesa-cmd port stati 1-8 pac
Port  Rx Packets          Tx Packets
----  ------------------  ------------------
1     50                  0
2     0                   50
3     0                   0
4     0                   0
5     0                   0
6     0                   0
7     0                   0
8     76                  0
----

Dump API/AIL state for port 1-4:

----
# mesa-cmd deb api ail port 1-4
Application Interface Layer
===========================

Port
-----

Mapping:

Port  Chip Port  Chip  Max BW  MIIM Bus  MIIM Addr  MIIM Chip
0     0          0     1G      0         0          0
1     1          0     1G      0         1          0
2     2          0     1G      -1        0          0
3     3          0     1G      -1        0          0

Configuration:

Port  Interface    Serdes     Speed     Aneg  Obey      Generate  Max Length
0     SGMII        SGMII      1Gfdx     No    Enabled   Enabled   1518+0
1     SGMII        SGMII      1Gfdx     No    Enabled   Enabled   1518+0
2     SERDES       1000BaseX  1Gfdx     No    Disabled  Disabled  1518+0
3     SERDES       1000BaseX  1Gfdx     No    Disabled  Disabled  1518+0

Forwarding:

Port  State  Forwarding  STP State   Auth State  Rx Fwd    Tx Fwd    Aggr Fwd
0     Up     Enabled     Forwarding  Both        Enabled   Enabled   Enabled
1     Up     Enabled     Forwarding  Both        Enabled   Enabled   Enabled
2     Down   Enabled     Forwarding  Both        Disabled  Disabled  Disabled
3     Down   Enabled     Forwarding  Both        Disabled  Disabled  Disabled
----

Show all trace levels:

----
# mesa-cmd deb tr
Module   Group       Level
-------  ----------  -----
api_ail  afi         error
api_ail  clock       error
api_ail  default     error
api_ail  emul        error
api_ail  evc         error
api_ail  fdma        error
api_ail  fdma_irq    error
api_ail  hqos        error
api_ail  hwprot      error
api_ail  l2          error
api_ail  l3          error
api_ail  macsec      error
api_ail  mpls        error
api_ail  oam         error
api_ail  packet      error
api_ail  phy         error
api_ail  port        error
api_ail  qos         error
api_ail  reg_check   error
api_ail  security    error
api_ail  ts          error
api_ail  vcap        error
api_cil  afi         error
api_cil  clock       error
api_cil  default     error
api_cil  emul        error
api_cil  evc         error
api_cil  fdma        error
api_cil  fdma_irq    error
api_cil  hqos        error
api_cil  hwprot      error
api_cil  l2          error
api_cil  l3          error
api_cil  macsec      error
api_cil  mpls        error
api_cil  oam         error
api_cil  packet      error
api_cil  phy         error
api_cil  port        error
api_cil  qos         error
api_cil  reg_check   error
api_cil  security    error
api_cil  ts          error
api_cil  vcap        error
cli      default     error
debug    default     error
ip       default     error
json_rpc default     error
mac      default     error
main     default     error
main     meba        error
port     default     error
regio    default     error
symreg   default     error
test     default     error
vlan     default     error

----

Enable debug trace for port API at AIL and show the trace level:

----
# mesa-cmd deb tr api_ail port debug
# mesa-cmd deb tr api_ail port
Module   Group       Level
-------  ----------  -----
api_ail  port        debug
----

Read chip ID in different ways using symbolic register access:

----
# mesa-cmd debug sym read help
Description:
------------
Read one/many switch register(s).

Syntax:
-------
Debug Sym Read <word128>

Parameters:
-----------
<word128>: Register pattern on the form 'target[t]:reggrp[g]:reg[r]', where
        'target' is the name of the target (e.g. dev).
        'reggrp' is the name of the register group.
        'reg'    is the name of the register.
        t        is a list of target replications if applicable.
        g        is a list of register group replications if applicable.
        r        is a list of register replications if applicable.
        If a given replication (t, g, r) is omitted, all applicable replications will be accessed.
        Both 'target', 'reggrp' and 'reg' may be omitted, which corresponds to wildcarding that part
        of the name. Matches are exact, but wildcards ('*', '?') are allowed.
# mesa-cmd debug sym read devcpu_gcb:chip_regs:chip_id
Register                     Value      Decimal    31     24 23     16 15      8 7       0
DEVCPU_GCB:CHIP_REGS:CHIP_ID 0x174150e9  390156521 0001.0111.0100.0001.0101.0000.1110.1001
1 match found
# mesa-cmd debug sym read devcpu_gcb::chip_id
Register                     Value      Decimal    31     24 23     16 15      8 7       0
DEVCPU_GCB:CHIP_REGS:CHIP_ID 0x174150e9  390156521 0001.0111.0100.0001.0101.0000.1110.1001
1 match found
# mesa-cmd debug sym read ::chip_id
Register                     Value      Decimal    31     24 23     16 15      8 7       0
DEVCPU_GCB:CHIP_REGS:CHIP_ID 0x174150e9  390156521 0001.0111.0100.0001.0101.0000.1110.1001
1 match found
# mesa-cmd debug sym read ::chip*
Register                     Value      Decimal    31     24 23     16 15      8 7       0
DEVCPU_GCB:CHIP_REGS:CHIP_ID 0x174150e9  390156521 0001.0111.0100.0001.0101.0000.1110.1001
1 match found

----
